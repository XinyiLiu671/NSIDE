#!/usr/bin/perl -w
use strict;
use File::Basename;
use IPC::Cmd qw[can_run run];
use POSIX;
use threads;
use Thread::Queue;
use Statistics::R;
use Array::Utils;
use File::Path qw[rmtree];
use Getopt::Long;

my $usage = <<USAGE;

SYSNOPSIS
------- ------- ------- ------- ------- ------- -------
NSIDE_SemSim.pl V5.17, written by Xinyi Liu       
------- ------- ------- ------- ------- ------- -------

This program is used to quantitatively compute average
gene simularity (semantic simularity in directed
acyclic graph of gene ontology terms) inside single
NSIDE by GOSemSim and test whether the simularity is
higher than random in parallel.

Reference:
1) Yu et al., Methods in Molecular Biology (2020)
2) Yu et al., Bioinformatics (2010)

------- ------- ------- ------- ------- ------- -------

Iutput files (details in "Options"):

1. NSIDE_annotations.txt generated by NSIDE_Annotate.pl
   "-m element --detail": annotated NSIDE, including at
   least 5 columns:
   1)   NSIDEid;
   2)   Size of NSIDE: number of beads in the NSIDE;
   3)   Type of NSIDE: "Cis" means all beads in the
        NSIDE belong to same chromatin, otherwise
        "Trans";
   4)   List of BeadID of all beads in the NSIDE.
   5)   Number of elements;
   6-n) If input annotation file: specified
        statistics of values (by --method) in each
        specfied column (by -c).
   n+1) List of elements.

------- ------- ------- ------- ------- ------- -------

Output file:

1. NSIDE_annotations_SemSim_Size_ont_measure_drop
   _combine.txt: annotated NSIDE containing semantice
   simularity results:
   1-n) Same as NSIDE_annotaion.txt;
   n+1) SemSim: average semantic simularity of genes;
   n+2) zscore_SemSim: standardized z of semantic
        simularity; 
   n+3) p_SemSim: pvalue of semantic simularity;
   > If "--readable":
   n+4) Official gene symbols of genes;
   n+5) List of elements.
   > Else:
   n+4) List of elements.
2. GenesAvailable_ont_drop.ids: id of all annotated
   genes in the selected aspect of GO after dropping
   the selected evidence code(s). 

------- ------- ------- ------- ------- ------- -------

Usage:

NSIDE_SemSim.pl -i NSIDE_annotations.txt [Options]

NSIDE_SemSim.pl -i NSIDE_annotations.txt -cs 2
                --species Mm --keytype REFSEQ
                --ont BP --drop IEA 
                --measure Wang --combine max
                --random 100
                --readable
                -o output_folder_name

------- ------- ------- ------- ------- ------- -------

Options:
 -i|--input      > NSIDE_annotation.txt
                 > !Notice:
                 > Must contain a list of genes in the
                   last column!
                 > The keytype of gene names should NOT
                   be "SYMBOL", "ALIAS", "COMMON" or
                   "GENENAME" because gene symbols
                   cannot be relied upon to be uniquely
                   mapped onto a single gene.
 -cs|cutoffsize  > Cutoff (>=) of NSIDE size used to
                   calculate simularity and output.
                   Default is 2.
                 > !Notice:
                   NSIDE with only one gene will also
                   be removed from the output.
 --species       > Species, "Mm" for house mouse
                   (default) or "Hs" for human.
 --keytype       > Keytype of gene names. "REFSEQ"
                   (default), "ACCNUM", "ENSEMBL",
                   "ENSEMBLPROT", "ENSEMBLTRANS",
                   "ENTREZID", "ENZYME", "INTERPRO", 
                   "IPI", "OMIM", "PROBEID", "UNIGENE",
                   or "UNIPROT", please refer to the
                   mananual of R package
                   "AnnotationDbi".
                 > !Notice:
                 > The keytype of gene names should NOT
                   be "SYMBOL", "ALIAS", "COMMON" or
                   "GENENAME".
 --ont           > Aspect of ontology, "BP" for
                   biological process (default), "CC"
                   for cellular component or "MF" for
                   molecular function.
 --drop          > One or a set of evidence codes
                   separated by "," to drop from
                   calculating semantic simularity.
                   Default is NULL, please refer to
                   http://geneontology.org/docs/
                   guide-go-evidence-codes/
 --measure       > One of "Resnik", "Lin", "Rel",
                   "Jiang" and "Wang" (default).
                 > Notice!:
                 > If any evidence codes are dropped,
                   use IC-based methods (including
                   "Resnik", "Lin" and "Rel") with
                   caution because the IC value may
                   not be accurate!
                 > Please refer to https://yulab-smu.
                   top/biomedical-knowledge-mining-
                   book/semantic-similarity-overview.
                   html
 --combine       > One of "max" (default), "avg",
                   "rcmax", "BMA" for combining
                   simularity scores of multiple GO
                   tems associated with one gene.
                 > Notice!:
                 > "BMA" may lead to error in some
                   situations, if so, please try
                   "max", "avg" or "rcmax".
                 > If use "--ont CC", "avg" is better
                   than "max" in estimating mean and
                   sd  of simularity.
 --random        > Times of random-sampling for
                   estimating mean and standard
                   deviation of simularity of all gene
                   pairs, must be an integer, default
                   is 100.
 --force         > To speed processing, for some
                   commonly-used combinations of
                   parameters including --measure Wang,
                   --drop IEA or NULL, --combine max or
                   avg, the estimation process has
                   already been performed by sampling
                   1000 times for mean and sd of
                   simularity. Use "--force" to avoid
                   using these pre-processed values.
                   Default is FALSE.
 --readable      > Conver the gene names in the last
                   column into official gene symbols
                   and add a column in the output file,
                   default is FALSE.
                 > !Notice:
                 > The number of official gene symbols
                   may not be equal to the
                   "ElementNumber" because multiple
                   genes may have same official gene
                   symbol.
 --slicerow      > Maximum number of rows of tmp file,
                   only influence run time, recommand
                   --slicerow 20 (default).
 -p|--process    > Number of threads used for
                   calculation, default 8.                  
 -o|--output     > Output folder.
 -h|--help       > Print this usage.

------- ------- ------- ------- ------- ------- -------

USAGE
my $in_file    = '';
my $cutoffsize = 2;
my $species    = 'Mm';
my $keytype    = 'REFSEQ';
my $ont        = 'BP';
my $drop       = 'NULL';
my $measure    = 'Wang';
my $combine    = 'max';
my $random     = 100;
my $force      = 0;
my $readable   = 0;
my $slicerow   = 20;
my $process    = 8;
my $out_folder = dirname './';
my $help       = 0;

die $usage
  unless GetOptions(
  	"i|input=s"       => \$in_file,
    "cs|cutoffsize:i" => \$cutoffsize,
    "species:s"       => \$species,
  	"keytype:s"       => \$keytype,
  	"ont:s"           => \$ont,
  	"drop:s"          => \$drop,
  	"measure:s"       => \$measure,
  	"combine:s"       => \$combine,
  	"random:i"        => \$random,
   	"force"           => \$force,
  	"readable"        => \$readable,
  	"slicerow:i"      => \$slicerow,
    "p|process:i"     => \$process,
    "o|output:s"      => \$out_folder,
    "h|help"          => \$help,
  );

##########################################################################################
# Check the parameter infomation 
##########################################################################################  
die $usage if $help;

my $datestring = localtime(); 
warn("$datestring: Checking runing environment and parameters...\n");

# Check the running environment
can_run('R') or die 'R is not executable!';
# check_library('GOSemSim') or die 'R package "GOSemSim" has not been installed!';
if ($species eq "Hs"){
	check_library('org.Hs.eg.db') or die 'R package "org.Hs.eg.db" has not been installed!';
}elsif ($species eq "Mm"){
	check_library('org.Mm.eg.db') or die 'R package "org.Mm.eg.db" has not been installed!';
}
# can_run('NSIDE_SemSim_sub.pl') or die 'NSIDE_SemSim_sub.pl is not executable!';

# Check the input file
die "No NSIDE_annotations file!\n" unless -s $in_file;

# Check the parameters
# --species
my $library;
my $bimap;
my $srcSpecies;
if ($species eq "Hs"){
	$library = 'org.Hs.eg.db';
	$bimap = 'org.Hs.egGO';
	$srcSpecies = 'HOMSA';
}elsif ($species eq "Mm"){
	$library = 'org.Mm.eg.db';
	$bimap = 'org.Mm.egGO';
	$srcSpecies = 'MUSMU';
}else{
	die "Unknown species: $species!\n";
}

# --keytype
my @All_keytypes = qw(REFSEQ ACCNUM ENSEMBL ENSEMBLPROT ENSEMBLPROT ENSEMBLPROT ENTREZID ENZYME INTERPRO IPI OMIM PROBEID UNIGENE UNIPROT);
my $matched = check_paras(\@All_keytypes, $keytype);
die "Unknown keytype: $keytype!\n" unless ($matched == 1);

# --ont
my @All_onts = qw(BP MF CC);
$matched = check_paras(\@All_onts, $ont);
die "Unknown ont: $ont!\n" unless ($matched == 1);

# --drop
my @drop = split(/,/, $drop);
my @All_drops = qw(NULL EXP IDA IPI IMP IGI IEP HTP HDA HMP HGI HEP IBA IBD IKR IRD ISS ISO ISA ISM IGC RCA TAS NAS IC ND IEA);
foreach my $drop_cur (@drop){
	$matched = check_paras(\@All_drops, $drop_cur);
	die "Unknown drop: $drop_cur!\n" unless ($matched == 1);
}
my $drop_R = join(",", map { qq/"$_"/ } @drop);
my $drop_Avai = join(" &", map { qq/GOMap\@geneAnno\$EVIDENCE != "$_"/ } @drop);

# --measure
my @All_measures = qw(Resnik Lin Rel Jiang Wang);
$matched = check_paras(\@All_measures, $measure);
die "Unknown measure: $measure!\n" unless ($matched == 1);

my $computeIC;
if ($measure eq "Wang"){
	$computeIC = "FALSE";
}elsif ("Resnik|Lin|Rel|Jiang" =~ $measure){
	$computeIC = "TRUE";
}elsif ($measure eq "TCSS"){
	$computeIC = "TRUE";
}

# --combine
my @All_combines = qw(max avg rcmax BMA);
$matched = check_paras(\@All_combines, $combine);
die "Unknown combine: $combine!\n" unless ($matched == 1);

# --readable
if ($readable){
	$readable = "TRUE";
}else{
	$readable = "FALSE";
}

########################################################################################## 
# Output files
##########################################################################################
# Make output directary
$out_folder =~ s/[\/|\|]+$//;
mkdir $out_folder unless -d $out_folder;

# File handles
my $basename =  basename($in_file, qw(.txt));
my $name = '';
if ($basename =~ /NSIDE_annotations_(.*)/){$name = $1;}

my $out_semsim_file = '';
my $out_GA_file = $out_folder . "/GenesAvailable_$ont" . "_$drop" . ".ids";
my $tmp_folder = '';
my $tmp_filt_in_file = '';

if ($name ne ''){
  $out_semsim_file = $out_folder . "/NSIDE_annotations_SemSim_$name" . "_Size$cutoffsize" . "_$ont" . "_$measure" . "_$drop" . "_$combine" . ".txt";
  $tmp_folder = $out_folder . "/tmpFiles_" . $name;
  $tmp_filt_in_file = $tmp_folder . "/tmp_filt_Input_" . $name . ".txt";
}else{
  $out_semsim_file = $out_folder . "/NSIDE_annotations_SemSim_Size$cutoffsize" . "_$ont" . "_$measure" . "_$drop" . "_$combine" . ".txt";
  $tmp_folder = $out_folder . "/tmpFiles";
  $tmp_filt_in_file = $tmp_folder . "/tmp_filt_Input.txt"
}

mkdir $tmp_folder unless -d $tmp_folder;

##########################################################################################
# Estimate mean and sd of semantic simularity population.
# For classical parameters, skip the estimation.
##########################################################################################
$datestring = localtime(); 
warn("$datestring: Estimating mean and sd of semantic simularity population...\n");

my $mean_random;
my $sd_random;
my $pvalue_sk;

if ($force){
	my $R = Statistics::R->new();
	my $R_cmds = <<EOF;
	suppressPackageStartupMessages(library(GOSemSim))
	suppressPackageStartupMessages(library($library))
	bimap <- $bimap
	All_Genes <- mappedkeys(bimap)
	All_Genes <- intraIDMapper(All_Genes, species="$srcSpecies", srcIDType="EG", destIDType="$keytype")
	GOMap <- godata("$library", keytype = "$keytype", ont="$ont", computeIC = "$computeIC", processTCSS = "FALSE")
	GeneNum_random = 10
	results_random = vector()
	for (i in c(1:$random)){
		genes_random <- sample(All_Genes, GeneNum_random)
		mtx_random <- mgeneSim(genes_random, semData=GOMap, measure="$measure", drop = c("$drop_R"), combine="$combine", verbose=FALSE)
		result_random <- mean(mtx_random[upper.tri(mtx_random)])
		results_random <- c(results_random, result_random)
	}
	mean_random = mean(results_random)
	sd_random = sd(results_random) * sqrt(45)
	psk = shapiro.test(results_random)
	pvalue_sk = psk\$p.value
	mean_random
	sd_random
	pvalue_sk
EOF
	$R -> run($R_cmds);
	$mean_random = $R -> get("mean_random");
	$sd_random = $R -> get("sd_random");
	$pvalue_sk = $R -> get("pvalue_sk");
	$R -> stop();
}else{
	if (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.373068;
		$sd_random = 0.5740943;
		$pvalue_sk = 3.849e-09;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.1117192;
		$sd_random = 0.1385589;
		$pvalue_sk = 2.2e-16;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.3216828;
		$sd_random = 0.5678023;
		$pvalue_sk = 3.264957e-13;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.1134975;
		$sd_random = 0.1627088;
		$pvalue_sk = 1.096212e-23;

	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.7281449;
		$sd_random = 0.5870041;
		$pvalue_sk = 0.3320381;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.3430327;
		$sd_random = 0.2600589;
		$pvalue_sk = 1.06471e-08;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.6933057;
		$sd_random = 0.6727624;
		$pvalue_sk = 0.1633935;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.3461304;
		$sd_random = 0.2853048;
		$pvalue_sk = 9.541469e-10;

	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.7453032;
		$sd_random = 0.9697994;
		$pvalue_sk = 2.530742e-08;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.2739963;
		$sd_random = 0.4704052;
		$pvalue_sk = 2.58646e-13;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.7198872;
		$sd_random = 1.092545;
		$pvalue_sk = 6.027189e-10;
	}elsif (($species eq "Hs") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.306655;
		$sd_random = 0.5624226;
		$pvalue_sk = 7.513396e-13;

	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.3913242;
		$sd_random = 0.5449009;
		$pvalue_sk = 3.957e-09;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.1436903;
		$sd_random = 0.285162;
		$pvalue_sk = 2.2e-16;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.3357078;
		$sd_random = 0.4976803;
		$pvalue_sk = 1.562e-08;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "BP") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.1361889;
		$sd_random = 0.3184298;
		$pvalue_sk = 2.2e-16;

	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.7181261;
		$sd_random = 0.627217;
		$pvalue_sk = 0.3939;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.3556158;
		$sd_random = 0.2342059;
		$pvalue_sk = 6.218e-11;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.6262165;
		$sd_random = 0.6681878;
		$pvalue_sk = 0.005117;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "CC") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.3335896;
		$sd_random = 0.2721391;
		$pvalue_sk = 7.477e-12;

	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "NULL") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.5419414;
		$sd_random = 0.6949279;
		$pvalue_sk = 1.9e-05;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "NULL") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.2628531;
		$sd_random = 0.4159503;
		$pvalue_sk = 1.481e-13;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "IEA") && ($combine eq "max")){
		$random = 1000;
		$mean_random = 0.4728937;
		$sd_random = 0.7620977;
		$pvalue_sk = 6.304e-07;
	}elsif (($species eq "Mm") && ($measure eq "Wang") && ($ont eq "MF") && ($drop eq "IEA") && ($combine eq "avg")){
		$random = 1000;
		$mean_random = 0.2702979;
		$sd_random = 0.4963452;
		$pvalue_sk = 5.371e-10;
	}else{
		my $R = Statistics::R->new();
		my $R_cmds = <<EOF;
		suppressPackageStartupMessages(library(GOSemSim))
		suppressPackageStartupMessages(library($library))
		bimap <- $bimap
		All_Genes <- mappedkeys(bimap)
		All_Genes <- intraIDMapper(All_Genes, species="$srcSpecies", srcIDType="EG", destIDType="$keytype")
		GOMap <- godata("$library", keytype = "$keytype", ont="$ont", computeIC = "$computeIC", processTCSS = "FALSE")
		GeneNum_random = 10
		results_random = vector()
		for (i in c(1:$random)){
			genes_random <- sample(All_Genes, GeneNum_random)
			mtx_random <- mgeneSim(genes_random, semData=GOMap, measure="$measure", drop = "$drop", combine="$combine", verbose=FALSE)
			result_random <- mean(mtx_random[upper.tri(mtx_random)])
			results_random <- c(results_random, result_random)
		}
		mean_random = mean(results_random)
		sd_random = sd(results_random) * sqrt(45)
		psk = shapiro.test(results_random)
		pvalue_sk = psk\$p.value
		mean_random
		sd_random
		pvalue_sk
EOF
		$R -> run($R_cmds);
		$mean_random = $R -> get("mean_random");
		$sd_random = $R -> get("sd_random");
		$pvalue_sk = $R -> get("pvalue_sk");
		$R -> stop();
	}
}

##########################################################################################
# Load the DAG of GO and get available gene ids
##########################################################################################
$datestring = localtime(); 
warn("$datestring: Getting available gene ids...\n");

unless (-s $out_GA_file){
	my $R2 = Statistics::R->new();
	my $R2_cmds = <<EOF;
	suppressPackageStartupMessages(library(GOSemSim))
	suppressPackageStartupMessages(library($library))
	GOMap <- godata("$library", keytype = "$keytype", ont="$ont", computeIC = "$computeIC", processTCSS = "FALSE")
	Genes_Available = unique(GOMap\@geneAnno[which($drop_Avai),"$keytype"])
	mean_random <- $mean_random
	sd_random <- $sd_random
	mean_random
	sd_random
	write.table(Genes_Available,"$out_GA_file",row.names=FALSE,col.names=FALSE,sep="\t",quote = FALSE)
EOF
	$R2 -> run($R2_cmds);
}

##########################################################################################
# Generate split input files
##########################################################################################
$datestring = localtime(); 
warn("$datestring: Generating split input files...\n");

my $filt_line_counter = 0;
my $header;
my $k_of_zscore;

open( INPUT, "<", $in_file ) or die "$!";
open( FILT, ">", $tmp_filt_in_file ) or die "$!";

while(<INPUT>){
	chomp;
	my @F = split /\t/;
	$k_of_zscore = @F + 1;

	if (/Size/){
		my @NewTitle;
		if ($readable eq "TRUE"){
			@NewTitle = qw(SemSim zscore_SemSim p_SemSim GeneSymbols);
		}else{
			@NewTitle = qw(SemSim zscore_SemSim p_SemSim);
		} 
		splice(@F, -1, 0, @NewTitle);
		$header = join "\t", @F;
		next;
	}else{
		chomp;
		my @F = split /\t/;
		my $Size = $F[1];

		if ($Size >= $cutoffsize){
			print FILT "$_\n";
			$filt_line_counter += 1;
		}
	}
}

close INPUT;
close FILT;

my $split_cmd = "split -l $slicerow -d -a 7 $tmp_filt_in_file $tmp_folder/FiltInputSlice";
run_command($split_cmd);

# =cut
##########################################################################################
# Calculate semantic simularity of each NSIDE in parallel
##########################################################################################
$datestring = localtime(); 
warn("$datestring: Calculating semantic simularity of each NSIDE in parallel...\n");

my @semsim_cmds;
my $slice_file_num = ceil($filt_line_counter / $slicerow);

for (my $i = 0; $i < $slice_file_num; $i += 1){
	my $index = sprintf("%07d", $i);
	my $slice_file = "$tmp_folder/FiltInputSlice$index";
	my $semsim_cmd = "perl /data4/xyliu/Projects/NSIDE/PipelineTest/V6/SemSim_v6_sub_5.pl -i $slice_file --gene $out_GA_file --mean $mean_random --sd $sd_random --species $species --keytype $keytype --ont $ont --drop $drop --measure $measure --combine $combine --readable $readable -o $tmp_folder";
	push @semsim_cmds, $semsim_cmd;
}

run_parallel($process, @semsim_cmds);

##########################################################################################
# Combine result files
##########################################################################################
$datestring = localtime(); 
warn("$datestring: Combining result files...\n");

my $cat_cmd = "cat $tmp_folder/OutSem* | sort -k $k_of_zscore -n -r > $out_semsim_file";
run_command($cat_cmd);

my $sd_random_real = $sd_random / sqrt(45);
my $sed_cmd = "sed -i \"1i$header\" $out_semsim_file";
run_command($sed_cmd); 
$sed_cmd = "sed -i \"1i### Shapiro-Wilk normality test p value of sampling distribution = $pvalue_sk\" $out_semsim_file";
run_command($sed_cmd);
$sed_cmd = "sed -i \"1i### Randomly sample 10 genes for $random times: mean = $mean_random, sd = $sd_random_real\" $out_semsim_file";
run_command($sed_cmd); 

##########################################################################################
# Clean up tmp files
##########################################################################################
rmtree $tmp_folder,{verbose => 0};
# rmtree $tmp_folder;

# =cut
##########################################################################################
# Subroutines
##########################################################################################
# Check whether R package has been installed
# Parameters：$library
sub check_library {
	my $library = shift;
	my $command = "R -e \'library($library)\'";
	my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf ) =
	    run( command => $command, verbose => 0 );
	return $success;
}

# Check whether the input para is one of the expected parameters
# Parameters：\@paras, $para
sub check_paras {
	my @paras = @{$_[0]};
	my $para = $_[1];

	my $matched = 0;
	foreach my $para_cur (@paras){
		if ($para_cur eq $para){
			$matched += 1;
		}
	}

	return $matched;
}

# Run commands and report errors
# Parameters：$command
sub run_command {
  my $command = shift;
  # warn "\t$command\n";
  my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf ) =
    run( command => $command, verbose => 1 );
  if ($success) {
    # warn "\tDone: $command!\n";
  }
  else {
    my @stderrs = @$stderr_buf;
    warn "\t$command:\n";
    warn "Something went wrong:\n@stderrs";
  }   
}

# Given commands, run them in multiple threads
# Parameters：$process_num, @commonds
sub run_parallel{
  my ($process_num, @missions) = @_;
  my $stream = Thread::Queue->new(@missions,undef);
  my $mission_num = scalar @missions;

  #assgn the task
  my @running = ();
  my @Threads;
  while (@Threads < @missions) {
      @running = threads->list(threads::running);

      if ( @running < $process_num) {
      my $command = $stream->dequeue();
          my $thread = threads->new(\&run_command,$command);
          push (@Threads, $thread);
          my $tid = $thread->tid;
      }
      @running = threads->list(threads::running);
      foreach my $thr (@Threads) {
          if ($thr->is_running()) {
                my $tid = $thr->tid;
          }
          elsif ($thr->is_joinable()) {
                my $tid = $thr->tid;
                $thr->join;
          }
      }
      @running = threads->list(threads::running);
  }

  #join the threads
  while (@running) {
        foreach my $thr (@Threads) {
            $thr->join if ($thr->is_joinable());
        }
        @running = threads->list(threads::running);
        sleep(3);
  }
  return 0;
}
